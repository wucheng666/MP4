<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <script src="./mp4box.simple.min.js"></script>
    <script src="./mp4box.all.min.js"></script>
    <style>

      .video-track {
        height: 360px;
        width: 640px;
        background: #ddd;
      }
    </style>
  </head>
  <body>
    <div class="video-track">
      <video controls></video>
    </div>
  </body>
  <script src="./index.js"></script>
  <script>
    var video = document.querySelector('video')

    // var assetURL = './TestSetJsonOutFrag.mp4';
    var assetURL = 'https://wucheng666.github.io/MP4/parseBusinessData/setJsonOutFrag.mp4'
    var mimeCodec = 'video/mp4; codecs="avc1.640028,avc1.640029,mp4a.40.2"'
    var totalSegments = 5
    var segmentLength = 0
    var segmentDuration = 0
    var bytesFetched = 0
    var requestedSegments = []
    var allBuffer = []

    for (var i = 0; i < totalSegments; ++i) requestedSegments[i] = false

    var mediaSource = null
    if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {
      mediaSource = new MediaSource()
      //console.log(mediaSource.readyState); // closed
      video.src = URL.createObjectURL(mediaSource)
      mediaSource.addEventListener('sourceopen', sourceOpen)
    } else {
      console.error('Unsupported MIME type or codec: ', mimeCodec)
    }

    var sourceBuffer = null
    function sourceOpen(_) {
      sourceBuffer = mediaSource.addSourceBuffer(mimeCodec)
      getFileLength(assetURL, function(fileLength) {
        console.log(fileLength, (fileLength / 1024 / 1024).toFixed(2), 'MB')
        //totalLength = fileLength;
        segmentLength = Math.round(fileLength / totalSegments)
        //console.log(totalLength, segmentLength);
        fetchRange(assetURL, 0, segmentLength, appendSegment)
        requestedSegments[0] = true
        video.addEventListener('timeupdate', checkBuffer)
        video.addEventListener('canplay', function() {
          segmentDuration = video.duration / totalSegments
          video.play()
        })
        video.addEventListener('seeking', seek)
      })
    }

    function getFileLength(url, cb) {
      var xhr = new XMLHttpRequest()
      xhr.open('head', url)
      xhr.onload = function() {
        cb(xhr.getResponseHeader('content-length'))
      }
      xhr.send()
    }

    function fetchRange(url, start, end, cb) {
      var xhr = new XMLHttpRequest()
      xhr.open('get', url)
      xhr.responseType = 'arraybuffer'
//       xhr.responseType = 'blob'
      xhr.setRequestHeader('Range', 'bytes=' + start + '-' + end)
      xhr.onload = function() {
        console.log('fetched bytes: ', start, end)
        bytesFetched += end - start + 1
        cb(xhr.response)
      }
      xhr.send()
    }

    function appendSegment(chunk) {

//       receivedData(blob)
      sourceBuffer.appendBuffer(chunk)
      allBuffer.push(chunk)
    }

    function checkBuffer(_) {
      var currentSegment = getCurrentSegment()
      if (currentSegment === totalSegments && haveAllSegments()) {
        console.log('last segment', mediaSource.readyState)
        console.log(allBuffer)
        mediaSource.endOfStream()
        video.removeEventListener('timeupdate', checkBuffer)
      } else if (shouldFetchNextSegment(currentSegment)) {
        requestedSegments[currentSegment] = true
        console.log('time to fetch next chunk', video.currentTime)
        fetchRange(assetURL, bytesFetched, bytesFetched + segmentLength, appendSegment)
      }
      //console.log(video.currentTime, currentSegment, segmentDuration);
    }

    function seek(e) {
      console.log(e)
      if (mediaSource.readyState === 'open') {
        sourceBuffer.abort()
        console.log(mediaSource.readyState)
      } else {
        console.log('seek but not open?')
        console.log(mediaSource.readyState)
      }
    }

    function getCurrentSegment() {
      return ((video.currentTime / segmentDuration) | 0) + 1
    }

    function haveAllSegments() {
      return requestedSegments.every(function(val) {
        return !!val
      })
    }

    function shouldFetchNextSegment(currentSegment) {
      return (
        video.currentTime > segmentDuration * currentSegment * 0.8 &&
        !requestedSegments[currentSegment]
      )
    }
  </script>
</html>
